import os
import json
from typing import List
from fastapi import FastAPI, Request, Response, File, UploadFile
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from multi_vector_simulator import version as mvs_version

try:
    from worker import celery
except ModuleNotFoundError:
    from .worker import celery
import celery.states as states

from celery.app.control import Inspect


from typing import List

from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session


from . import crud, models, schemas
from .database import SessionLocal, engine



app = FastAPI()


SERVER_ROOT = os.path.dirname(__file__)

app.mount(
    "/static", StaticFiles(directory=os.path.join(SERVER_ROOT, "static")), name="static"
)

templates = Jinja2Templates(directory=os.path.join(SERVER_ROOT, "templates"))


models.Base.metadata.create_all(bind=engine)

# option for routing `@app.X` where `X` is one of
# post: to create data.
# get: to read data.
# put: to update data.
# delete: to delete data.

# while it might be tempting to use BackgroundTasks for oemof simulation, those might take up
# resources and it is better to start them in an independent process. BackgroundTasks are for
# not resource intensive processes(https://fastapi.tiangolo.com/tutorial/background-tasks/)


# `127.0.0.1:8000/docs` endpoint will have autogenerated docs for the written code

# Test Driven Development --> https://fastapi.tiangolo.com/tutorial/testing/



# Dependency
def get_db():
    db = SessionLocal()
    try:
        print("Bordel")
        yield db
    finally:
        db.close()

@app.get("/tasks/", response_model=List[schemas.Token])
def read_users(request: Request, skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    tokens = crud.get_tokens(db, skip=skip, limit=limit)
    return templates.TemplateResponse(
        "list_tasks.html", {"request": request, "tokens": tokens}
    )


@app.get("/")
def index(request: Request) -> Response:

    return templates.TemplateResponse(
        "index.html", {"request": request, "mvs_version": mvs_version.version_num}
    )


@app.post("/sendjson/")
async def simulate_json_variable(request: Request):
    """Receive mvs simulation parameter in json post request and send it to simulator"""
    input_dict = await request.json()

    # send the task to celery
    task = celery.send_task("tasks.run_simulation", args=[input_dict], kwargs={})

    queue_answer = await check_task(task.id)

    return queue_answer


@app.post("/uploadjson/")
def simulate_uploaded_json_files(request: Request, json_file: UploadFile = File(...)):
    """Receive mvs simulation parameter in json post request and send it to simulator
    the value of `name` property of the input html tag should be `json_file` as the second
    argument of this function
    """
    json_content = jsonable_encoder(json_file.file.read())
    return run_simulation(request, input_json=json_content)


@app.post("/run_simulation")
def run_simulation(request: Request, input_json=None) -> Response:
    """Send a simulation task to a celery worker"""

    if input_json is None:
        input_dict = {
            "name": "dummy_json_input",
            "secondary_dict": {"val1": 2, "val2": [5, 6, 7, 8]},
        }
    else:
        input_dict = json.loads(input_json)

    # send the task to celery
    task = celery.send_task("tasks.run_simulation", args=[input_dict], kwargs={})
    db = SessionLocal()
    mvs_tk = models.Token(mvs_token=str(task.id))

    db.add(mvs_tk)
    db.commit()


    #crud.store_token(db, mvs_token=str(task.id))

    return templates.TemplateResponse(
        "submitted_task.html", {"request": request, "task_id": task.id}
    )


@app.get("/check/{task_id}")
async def check_task(task_id: str) -> JSONResponse:
    res = celery.AsyncResult(task_id)
    task = {"id": task_id, "status": res.state, "results": None}
    if res.state == states.PENDING:
        task["status"] = res.state
    else:
        task["status"] = "DONE"
        task["results"] = res.result
        if "ERROR" in task["results"]:
            task["status"] = "ERROR"
            task["results"] = json.loads(res.result)
    return JSONResponse(content=jsonable_encoder(task))
